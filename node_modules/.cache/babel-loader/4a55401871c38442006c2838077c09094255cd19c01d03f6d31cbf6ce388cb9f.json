{"ast":null,"code":"'use strict';\n\nimport NativeReanimatedModule from './NativeReanimated';\nimport { isWorkletFunction } from \"./commonTypes.js\";\nimport { shouldBeUseWeb } from \"./PlatformChecker.js\";\nimport { ReanimatedError, registerWorkletStackDetails } from \"./errors.js\";\nimport { jsVersion } from \"./platform-specific/jsVersion.js\";\nimport { shareableMappingCache, shareableMappingFlag } from \"./shareableMappingCache.js\";\nimport { logger } from \"./logger/index.js\";\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// running the code on separate VMs.\nconst SHOULD_BE_USE_WEB = shouldBeUseWeb();\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\nfunction isHostObject(value) {\n  'worklet';\n\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\nfunction isPlainJSObject(object) {\n  return Object.getPrototypeOf(object) === Object.prototype;\n}\n\n// The below object is used as a replacement for objects that cannot be transferred\n// as shareable values. In makeShareableCloneRecursive we detect if an object is of\n// a plain Object.prototype and only allow such objects to be transferred. This lets\n// us avoid all sorts of react internals from leaking into the UI runtime. To make it\n// possible to catch errors when someone actually tries to access such object on the UI\n// runtime, we use the below Proxy object which is instantiated on the UI runtime and\n// throws whenever someone tries to access its fields.\nconst INACCESSIBLE_OBJECT = {\n  __init: () => {\n    'worklet';\n\n    return new Proxy({}, {\n      get: (_, prop) => {\n        if (prop === '_isReanimatedSharedValue' || prop === '__remoteFunction') {\n          // not very happy about this check here, but we need to allow for\n          // \"inaccessible\" objects to be tested with isSharedValue check\n          // as it is being used in the mappers when extracting inputs recursively\n          // as well as with isRemoteFunction when cloning objects recursively.\n          // Apparently we can't check if a key exists there as HostObjects always\n          // return true for such tests, so the only possibility for us is to\n          // actually access that key and see if it is set to true. We therefore\n          // need to allow for this key to be accessed here.\n          return false;\n        }\n        throw new ReanimatedError(\"Trying to access property `\".concat(String(prop), \"` of an object which cannot be sent to the UI runtime.\"));\n      },\n      set: () => {\n        throw new ReanimatedError('Trying to write to an object which cannot be sent to the UI runtime.');\n      }\n    });\n  }\n};\nconst VALID_ARRAY_VIEWS_NAMES = ['Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array', 'BigInt64Array', 'BigUint64Array', 'DataView'];\nconst DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD = 30;\n// Below variable stores object that we process in makeShareableCloneRecursive at the specified depth.\n// We use it to check if later on the function reenters with the same object\nlet processedObjectAtThresholdDepth;\nexport function makeShareableCloneRecursive(value) {\n  let shouldPersistRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (SHOULD_BE_USE_WEB) {\n    return value;\n  }\n  if (depth >= DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n    // if we reach certain recursion depth we suspect that we are dealing with a cyclic object.\n    // this type of objects are not supported and cannot be transferred as shareable, so we\n    // implement a simple detection mechanism that remembers the value at a given depth and\n    // tests whether we try reenter this method later on with the same value. If that happens\n    // we throw an appropriate error.\n    if (depth === DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n      processedObjectAtThresholdDepth = value;\n    } else if (value === processedObjectAtThresholdDepth) {\n      throw new ReanimatedError('Trying to convert a cyclic object to a shareable. This is not supported.');\n    }\n  } else {\n    processedObjectAtThresholdDepth = undefined;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  const isTypeObject = type === 'object';\n  const isTypeFunction = type === 'function';\n  if ((isTypeObject || isTypeFunction) && value !== null) {\n    const cached = shareableMappingCache.get(value);\n    if (cached === shareableMappingFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached;\n    } else {\n      let toAdapt;\n      if (Array.isArray(value)) {\n        toAdapt = value.map(element => makeShareableCloneRecursive(element, shouldPersistRemote, depth + 1));\n        freezeObjectIfDev(value);\n      } else if (isTypeFunction && !isWorkletFunction(value)) {\n        // this is a remote function\n        toAdapt = value;\n        freezeObjectIfDev(value);\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else if (isPlainJSObject(value) && value.__workletContextObjectFactory) {\n        const workletContextObjectFactory = value.__workletContextObjectFactory;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n\n            return workletContextObjectFactory();\n          }\n        });\n        shareableMappingCache.set(value, handle);\n        return handle;\n      } else if (isPlainJSObject(value) || isTypeFunction) {\n        toAdapt = {};\n        if (isWorkletFunction(value)) {\n          if (__DEV__) {\n            const babelVersion = value.__initData.version;\n            if (babelVersion !== undefined && babelVersion !== jsVersion) {\n              throw new ReanimatedError(\"Mismatch between JavaScript code version and Reanimated Babel plugin version (\".concat(jsVersion, \" vs. \").concat(babelVersion, \").        \\nSee `https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#mismatch-between-javascript-code-version-and-reanimated-babel-plugin-version` for more details.\\nOffending code was: `\").concat(getWorkletCode(value), \"`\"));\n            }\n            registerWorkletStackDetails(value.__workletHash, value.__stackDetails);\n          }\n          if (value.__stackDetails) {\n            // `Error` type of value cannot be copied to the UI thread, so we\n            // remove it after we handled it in dev mode or delete it to ignore it in production mode.\n            // Not removing this would cause an infinite loop in production mode and it just\n            // seems more elegant to handle it this way.\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings representing the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(value.__initData, true, depth + 1);\n        }\n        for (const [key, element] of Object.entries(value)) {\n          if (key === '__initData' && toAdapt.__initData !== undefined) {\n            continue;\n          }\n          toAdapt[key] = makeShareableCloneRecursive(element, shouldPersistRemote, depth + 1);\n        }\n        freezeObjectIfDev(value);\n      } else if (value instanceof RegExp) {\n        const pattern = value.source;\n        const flags = value.flags;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n\n            return new RegExp(pattern, flags);\n          }\n        });\n        shareableMappingCache.set(value, handle);\n        return handle;\n      } else if (value instanceof Error) {\n        const {\n          name,\n          message,\n          stack\n        } = value;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n\n            // eslint-disable-next-line reanimated/use-reanimated-error\n            const error = new Error();\n            error.name = name;\n            error.message = message;\n            error.stack = stack;\n            return error;\n          }\n        });\n        shareableMappingCache.set(value, handle);\n        return handle;\n      } else if (value instanceof ArrayBuffer) {\n        toAdapt = value;\n      } else if (ArrayBuffer.isView(value)) {\n        // typed array (e.g. Int32Array, Uint8ClampedArray) or DataView\n        const buffer = value.buffer;\n        const typeName = value.constructor.name;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n\n            if (!VALID_ARRAY_VIEWS_NAMES.includes(typeName)) {\n              throw new ReanimatedError(\"Invalid array view name `\".concat(typeName, \"`.\"));\n            }\n            const constructor = global[typeName];\n            if (constructor === undefined) {\n              throw new ReanimatedError(\"Constructor for `\".concat(typeName, \"` not found.\"));\n            }\n            return new constructor(buffer);\n          }\n        });\n        shareableMappingCache.set(value, handle);\n        return handle;\n      } else {\n        // This is reached for object types that are not of plain Object.prototype.\n        // We don't support such objects from being transferred as shareables to\n        // the UI runtime and hence we replace them with \"inaccessible object\"\n        // which is implemented as a Proxy object that throws on any attempt\n        // of accessing its fields. We argue that such objects can sometimes leak\n        // as attributes of objects being captured by worklets but should never\n        // be used on the UI runtime regardless. If they are being accessed, the user\n        // will get an appropriate error message.\n        const inaccessibleObject = makeShareableCloneRecursive(INACCESSIBLE_OBJECT);\n        shareableMappingCache.set(value, inaccessibleObject);\n        return inaccessibleObject;\n      }\n      const adapted = NativeReanimatedModule.makeShareableClone(toAdapt, shouldPersistRemote, value);\n      shareableMappingCache.set(value, adapted);\n      shareableMappingCache.set(adapted);\n      return adapted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(value, shouldPersistRemote, undefined);\n}\nconst WORKLET_CODE_THRESHOLD = 255;\nfunction getWorkletCode(value) {\n  var _value$__initData;\n  // @ts-ignore this is fine\n  const code = value === null || value === void 0 || (_value$__initData = value.__initData) === null || _value$__initData === void 0 ? void 0 : _value$__initData.code;\n  if (!code) {\n    return 'unknown';\n  }\n  if (code.length > WORKLET_CODE_THRESHOLD) {\n    return \"\".concat(code.substring(0, WORKLET_CODE_THRESHOLD), \"...\");\n  }\n  return code;\n}\nfunction isRemoteFunction(value) {\n  'worklet';\n\n  return !!value.__remoteFunction;\n}\n\n/**\n * We freeze\n *\n * - Arrays,\n * - Remote functions,\n * - Plain JS objects,\n *\n * That are transformed to a shareable with a meaningful warning. This should\n * help detect issues when someone modifies data after it's been converted.\n * Meaning that they may be doing a faulty assumption in their code expecting\n * that the updates are going to automatically propagate to the object sent to\n * the UI thread. If the user really wants some objects to be mutable they\n * should use shared values instead.\n */\nfunction freezeObjectIfDev(value) {\n  if (!__DEV__) {\n    return;\n  }\n  Object.entries(value).forEach(_ref => {\n    let [key, element] = _ref;\n    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n    if (!descriptor.configurable) {\n      return;\n    }\n    Object.defineProperty(value, key, {\n      get() {\n        return element;\n      },\n      set() {\n        logger.warn(\"Tried to modify key `\".concat(key, \"` of an object which has been already passed to a worklet. See \\nhttps://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#tried-to-modify-key-of-an-object-which-has-been-converted-to-a-shareable \\nfor more details.\"));\n      }\n    });\n  });\n  Object.preventExtensions(value);\n}\nexport function makeShareableCloneOnUIRecursive(value) {\n  'worklet';\n\n  if (SHOULD_BE_USE_WEB) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function cloneRecursive(value) {\n    if (typeof value === 'object' && value !== null || typeof value === 'function') {\n      if (isHostObject(value)) {\n        // We call `_makeShareableClone` to wrap the provided HostObject\n        // inside ShareableJSRef.\n        return global._makeShareableClone(value, undefined);\n      }\n      if (isRemoteFunction(value)) {\n        // RemoteFunctions are created by us therefore they are\n        // a Shareable out of the box and there is no need to\n        // call `_makeShareableClone`.\n        return value.__remoteFunction;\n      }\n      if (Array.isArray(value)) {\n        return global._makeShareableClone(value.map(cloneRecursive), undefined);\n      }\n      const toAdapt = {};\n      for (const [key, element] of Object.entries(value)) {\n        toAdapt[key] = cloneRecursive(element);\n      }\n      return global._makeShareableClone(toAdapt, value);\n    }\n    return global._makeShareableClone(value, undefined);\n  }\n  return cloneRecursive(value);\n}\nfunction makeShareableJS(value) {\n  return value;\n}\nfunction makeShareableNative(value) {\n  if (shareableMappingCache.get(value)) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n\n      return value;\n    }\n  });\n  shareableMappingCache.set(value, handle);\n  return value;\n}\n\n/**\n * This function creates a value on UI with persistent state - changes to it on\n * the UI thread will be seen by all worklets. Use it when you want to create a\n * value that is read and written only on the UI thread.\n */\nexport const makeShareable = SHOULD_BE_USE_WEB ? makeShareableJS : makeShareableNative;","map":{"version":3,"names":["NativeReanimatedModule","isWorkletFunction","shouldBeUseWeb","ReanimatedError","registerWorkletStackDetails","jsVersion","shareableMappingCache","shareableMappingFlag","logger","SHOULD_BE_USE_WEB","MAGIC_KEY","isHostObject","value","isPlainJSObject","object","Object","getPrototypeOf","prototype","INACCESSIBLE_OBJECT","__init","Proxy","get","_","prop","concat","String","set","VALID_ARRAY_VIEWS_NAMES","DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD","processedObjectAtThresholdDepth","makeShareableCloneRecursive","shouldPersistRemote","arguments","length","undefined","depth","type","isTypeObject","isTypeFunction","cached","toAdapt","Array","isArray","map","element","freezeObjectIfDev","__workletContextObjectFactory","workletContextObjectFactory","handle","__DEV__","babelVersion","__initData","version","getWorkletCode","__workletHash","__stackDetails","key","entries","RegExp","pattern","source","flags","Error","name","message","stack","error","ArrayBuffer","isView","buffer","typeName","constructor","includes","global","inaccessibleObject","adapted","makeShareableClone","WORKLET_CODE_THRESHOLD","_value$__initData","code","substring","isRemoteFunction","__remoteFunction","forEach","_ref","descriptor","getOwnPropertyDescriptor","configurable","defineProperty","warn","preventExtensions","makeShareableCloneOnUIRecursive","cloneRecursive","_makeShareableClone","makeShareableJS","makeShareableNative","makeShareable"],"sources":["/Users/carter/WebstormProjects/personal-website/node_modules/react-native-reanimated/src/shareables.ts"],"sourcesContent":["'use strict';\nimport NativeReanimatedModule from './NativeReanimated';\nimport { isWorkletFunction } from './commonTypes';\nimport type {\n  ShareableRef,\n  FlatShareableRef,\n  WorkletFunction,\n} from './commonTypes';\nimport { shouldBeUseWeb } from './PlatformChecker';\nimport { ReanimatedError, registerWorkletStackDetails } from './errors';\nimport { jsVersion } from './platform-specific/jsVersion';\nimport {\n  shareableMappingCache,\n  shareableMappingFlag,\n} from './shareableMappingCache';\nimport { logger } from './logger';\n\n// for web/chrome debugger/jest environments this file provides a stub implementation\n// where no shareable references are used. Instead, the objects themselves are used\n// instead of shareable references, because of the fact that we don't have to deal with\n// running the code on separate VMs.\nconst SHOULD_BE_USE_WEB = shouldBeUseWeb();\n\nconst MAGIC_KEY = 'REANIMATED_MAGIC_KEY';\n\nfunction isHostObject(value: NonNullable<object>) {\n  'worklet';\n  // We could use JSI to determine whether an object is a host object, however\n  // the below workaround works well and is way faster than an additional JSI call.\n  // We use the fact that host objects have broken implementation of `hasOwnProperty`\n  // and hence return true for all `in` checks regardless of the key we ask for.\n  return MAGIC_KEY in value;\n}\n\nfunction isPlainJSObject(object: object) {\n  return Object.getPrototypeOf(object) === Object.prototype;\n}\n\n// The below object is used as a replacement for objects that cannot be transferred\n// as shareable values. In makeShareableCloneRecursive we detect if an object is of\n// a plain Object.prototype and only allow such objects to be transferred. This lets\n// us avoid all sorts of react internals from leaking into the UI runtime. To make it\n// possible to catch errors when someone actually tries to access such object on the UI\n// runtime, we use the below Proxy object which is instantiated on the UI runtime and\n// throws whenever someone tries to access its fields.\nconst INACCESSIBLE_OBJECT = {\n  __init: () => {\n    'worklet';\n    return new Proxy(\n      {},\n      {\n        get: (_: unknown, prop: string | symbol) => {\n          if (\n            prop === '_isReanimatedSharedValue' ||\n            prop === '__remoteFunction'\n          ) {\n            // not very happy about this check here, but we need to allow for\n            // \"inaccessible\" objects to be tested with isSharedValue check\n            // as it is being used in the mappers when extracting inputs recursively\n            // as well as with isRemoteFunction when cloning objects recursively.\n            // Apparently we can't check if a key exists there as HostObjects always\n            // return true for such tests, so the only possibility for us is to\n            // actually access that key and see if it is set to true. We therefore\n            // need to allow for this key to be accessed here.\n            return false;\n          }\n          throw new ReanimatedError(\n            `Trying to access property \\`${String(\n              prop\n            )}\\` of an object which cannot be sent to the UI runtime.`\n          );\n        },\n        set: () => {\n          throw new ReanimatedError(\n            'Trying to write to an object which cannot be sent to the UI runtime.'\n          );\n        },\n      }\n    );\n  },\n};\n\nconst VALID_ARRAY_VIEWS_NAMES = [\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'DataView',\n];\n\nconst DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD = 30;\n// Below variable stores object that we process in makeShareableCloneRecursive at the specified depth.\n// We use it to check if later on the function reenters with the same object\nlet processedObjectAtThresholdDepth: unknown;\n\nexport function makeShareableCloneRecursive<T>(\n  value: any,\n  shouldPersistRemote = false,\n  depth = 0\n): ShareableRef<T> {\n  if (SHOULD_BE_USE_WEB) {\n    return value;\n  }\n  if (depth >= DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n    // if we reach certain recursion depth we suspect that we are dealing with a cyclic object.\n    // this type of objects are not supported and cannot be transferred as shareable, so we\n    // implement a simple detection mechanism that remembers the value at a given depth and\n    // tests whether we try reenter this method later on with the same value. If that happens\n    // we throw an appropriate error.\n    if (depth === DETECT_CYCLIC_OBJECT_DEPTH_THRESHOLD) {\n      processedObjectAtThresholdDepth = value;\n    } else if (value === processedObjectAtThresholdDepth) {\n      throw new ReanimatedError(\n        'Trying to convert a cyclic object to a shareable. This is not supported.'\n      );\n    }\n  } else {\n    processedObjectAtThresholdDepth = undefined;\n  }\n  // This one actually may be worth to be moved to c++, we also need similar logic to run on the UI thread\n  const type = typeof value;\n  const isTypeObject = type === 'object';\n  const isTypeFunction = type === 'function';\n  if ((isTypeObject || isTypeFunction) && value !== null) {\n    const cached = shareableMappingCache.get(value);\n    if (cached === shareableMappingFlag) {\n      return value;\n    } else if (cached !== undefined) {\n      return cached as ShareableRef<T>;\n    } else {\n      let toAdapt: any;\n      if (Array.isArray(value)) {\n        toAdapt = value.map((element) =>\n          makeShareableCloneRecursive(element, shouldPersistRemote, depth + 1)\n        );\n        freezeObjectIfDev(value);\n      } else if (isTypeFunction && !isWorkletFunction(value)) {\n        // this is a remote function\n        toAdapt = value;\n        freezeObjectIfDev(value);\n      } else if (isHostObject(value)) {\n        // for host objects we pass the reference to the object as shareable and\n        // then recreate new host object wrapping the same instance on the UI thread.\n        // there is no point of iterating over keys as we do for regular objects.\n        toAdapt = value;\n      } else if (\n        isPlainJSObject(value) &&\n        value.__workletContextObjectFactory\n      ) {\n        const workletContextObjectFactory = value.__workletContextObjectFactory;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n            return workletContextObjectFactory();\n          },\n        });\n        shareableMappingCache.set(value, handle);\n        return handle as ShareableRef<T>;\n      } else if (isPlainJSObject(value) || isTypeFunction) {\n        toAdapt = {};\n        if (isWorkletFunction(value)) {\n          if (__DEV__) {\n            const babelVersion = value.__initData.version;\n            if (babelVersion !== undefined && babelVersion !== jsVersion) {\n              throw new ReanimatedError(`Mismatch between JavaScript code version and Reanimated Babel plugin version (${jsVersion} vs. ${babelVersion}).        \nSee \\`https://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#mismatch-between-javascript-code-version-and-reanimated-babel-plugin-version\\` for more details.\nOffending code was: \\`${getWorkletCode(value)}\\``);\n            }\n            registerWorkletStackDetails(\n              value.__workletHash,\n              value.__stackDetails!\n            );\n          }\n          if (value.__stackDetails) {\n            // `Error` type of value cannot be copied to the UI thread, so we\n            // remove it after we handled it in dev mode or delete it to ignore it in production mode.\n            // Not removing this would cause an infinite loop in production mode and it just\n            // seems more elegant to handle it this way.\n            delete value.__stackDetails;\n          }\n          // to save on transferring static __initData field of worklet structure\n          // we request shareable value to persist its UI counterpart. This means\n          // that the __initData field that contains long strings representing the\n          // worklet code, source map, and location, will always be\n          // serialized/deserialized once.\n          toAdapt.__initData = makeShareableCloneRecursive(\n            value.__initData,\n            true,\n            depth + 1\n          );\n        }\n\n        for (const [key, element] of Object.entries(value)) {\n          if (key === '__initData' && toAdapt.__initData !== undefined) {\n            continue;\n          }\n          toAdapt[key] = makeShareableCloneRecursive(\n            element,\n            shouldPersistRemote,\n            depth + 1\n          );\n        }\n        freezeObjectIfDev(value);\n      } else if (value instanceof RegExp) {\n        const pattern = value.source;\n        const flags = value.flags;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n            return new RegExp(pattern, flags);\n          },\n        });\n        shareableMappingCache.set(value, handle);\n        return handle as ShareableRef<T>;\n      } else if (value instanceof Error) {\n        const { name, message, stack } = value;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n            // eslint-disable-next-line reanimated/use-reanimated-error\n            const error = new Error();\n            error.name = name;\n            error.message = message;\n            error.stack = stack;\n            return error;\n          },\n        });\n        shareableMappingCache.set(value, handle);\n        return handle as ShareableRef<T>;\n      } else if (value instanceof ArrayBuffer) {\n        toAdapt = value;\n      } else if (ArrayBuffer.isView(value)) {\n        // typed array (e.g. Int32Array, Uint8ClampedArray) or DataView\n        const buffer = value.buffer;\n        const typeName = value.constructor.name;\n        const handle = makeShareableCloneRecursive({\n          __init: () => {\n            'worklet';\n            if (!VALID_ARRAY_VIEWS_NAMES.includes(typeName)) {\n              throw new ReanimatedError(\n                `Invalid array view name \\`${typeName}\\`.`\n              );\n            }\n            const constructor = global[typeName as keyof typeof global];\n            if (constructor === undefined) {\n              throw new ReanimatedError(\n                `Constructor for \\`${typeName}\\` not found.`\n              );\n            }\n            return new constructor(buffer);\n          },\n        });\n        shareableMappingCache.set(value, handle);\n        return handle as ShareableRef<T>;\n      } else {\n        // This is reached for object types that are not of plain Object.prototype.\n        // We don't support such objects from being transferred as shareables to\n        // the UI runtime and hence we replace them with \"inaccessible object\"\n        // which is implemented as a Proxy object that throws on any attempt\n        // of accessing its fields. We argue that such objects can sometimes leak\n        // as attributes of objects being captured by worklets but should never\n        // be used on the UI runtime regardless. If they are being accessed, the user\n        // will get an appropriate error message.\n        const inaccessibleObject =\n          makeShareableCloneRecursive<T>(INACCESSIBLE_OBJECT);\n        shareableMappingCache.set(value, inaccessibleObject);\n        return inaccessibleObject;\n      }\n      const adapted = NativeReanimatedModule.makeShareableClone(\n        toAdapt,\n        shouldPersistRemote,\n        value\n      );\n      shareableMappingCache.set(value, adapted);\n      shareableMappingCache.set(adapted);\n      return adapted;\n    }\n  }\n  return NativeReanimatedModule.makeShareableClone(\n    value,\n    shouldPersistRemote,\n    undefined\n  );\n}\n\nconst WORKLET_CODE_THRESHOLD = 255;\n\nfunction getWorkletCode(value: WorkletFunction) {\n  // @ts-ignore this is fine\n  const code = value?.__initData?.code;\n  if (!code) {\n    return 'unknown';\n  }\n  if (code.length > WORKLET_CODE_THRESHOLD) {\n    return `${code.substring(0, WORKLET_CODE_THRESHOLD)}...`;\n  }\n  return code;\n}\n\ntype RemoteFunction<T> = {\n  __remoteFunction: FlatShareableRef<T>;\n};\n\nfunction isRemoteFunction<T>(value: {\n  __remoteFunction?: unknown;\n}): value is RemoteFunction<T> {\n  'worklet';\n  return !!value.__remoteFunction;\n}\n\n/**\n * We freeze\n *\n * - Arrays,\n * - Remote functions,\n * - Plain JS objects,\n *\n * That are transformed to a shareable with a meaningful warning. This should\n * help detect issues when someone modifies data after it's been converted.\n * Meaning that they may be doing a faulty assumption in their code expecting\n * that the updates are going to automatically propagate to the object sent to\n * the UI thread. If the user really wants some objects to be mutable they\n * should use shared values instead.\n */\nfunction freezeObjectIfDev<T extends object>(value: T) {\n  if (!__DEV__) {\n    return;\n  }\n  Object.entries(value).forEach(([key, element]) => {\n    const descriptor = Object.getOwnPropertyDescriptor(value, key)!;\n    if (!descriptor.configurable) {\n      return;\n    }\n    Object.defineProperty(value, key, {\n      get() {\n        return element;\n      },\n      set() {\n        logger.warn(\n          `Tried to modify key \\`${key}\\` of an object which has been already passed to a worklet. See \nhttps://docs.swmansion.com/react-native-reanimated/docs/guides/troubleshooting#tried-to-modify-key-of-an-object-which-has-been-converted-to-a-shareable \nfor more details.`\n        );\n      },\n    });\n  });\n  Object.preventExtensions(value);\n}\n\nexport function makeShareableCloneOnUIRecursive<T>(\n  value: T\n): FlatShareableRef<T> {\n  'worklet';\n  if (SHOULD_BE_USE_WEB) {\n    // @ts-ignore web is an interesting place where we don't run a secondary VM on the UI thread\n    // see more details in the comment where USE_STUB_IMPLEMENTATION is defined.\n    return value;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function cloneRecursive(value: T): FlatShareableRef<T> {\n    if (\n      (typeof value === 'object' && value !== null) ||\n      typeof value === 'function'\n    ) {\n      if (isHostObject(value)) {\n        // We call `_makeShareableClone` to wrap the provided HostObject\n        // inside ShareableJSRef.\n        return global._makeShareableClone(\n          value,\n          undefined\n        ) as FlatShareableRef<T>;\n      }\n      if (isRemoteFunction<T>(value)) {\n        // RemoteFunctions are created by us therefore they are\n        // a Shareable out of the box and there is no need to\n        // call `_makeShareableClone`.\n        return value.__remoteFunction;\n      }\n      if (Array.isArray(value)) {\n        return global._makeShareableClone(\n          value.map(cloneRecursive),\n          undefined\n        ) as FlatShareableRef<T>;\n      }\n      const toAdapt: Record<string, FlatShareableRef<T>> = {};\n      for (const [key, element] of Object.entries(value)) {\n        toAdapt[key] = cloneRecursive(element);\n      }\n      return global._makeShareableClone(toAdapt, value) as FlatShareableRef<T>;\n    }\n    return global._makeShareableClone(value, undefined);\n  }\n  return cloneRecursive(value);\n}\n\nfunction makeShareableJS<T extends object>(value: T): T {\n  return value;\n}\n\nfunction makeShareableNative<T extends object>(value: T): T {\n  if (shareableMappingCache.get(value)) {\n    return value;\n  }\n  const handle = makeShareableCloneRecursive({\n    __init: () => {\n      'worklet';\n      return value;\n    },\n  });\n  shareableMappingCache.set(value, handle);\n  return value;\n}\n\n/**\n * This function creates a value on UI with persistent state - changes to it on\n * the UI thread will be seen by all worklets. Use it when you want to create a\n * value that is read and written only on the UI thread.\n */\nexport const makeShareable = SHOULD_BE_USE_WEB\n  ? makeShareableJS\n  : makeShareableNative;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}